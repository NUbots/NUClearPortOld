/*
 * This file is part of SegmentFilter.
 *
 * SegmentFilter is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SegmentFilter is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SegmentFilter.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright 2013 NUBots <nubots@nubots.net>
 */

#ifndef MODULES_VISION_SEGMENTFILTER_H
#define MODULES_VISION_SEGMENTFILTER_H

#include <nuclear> 
#include <string>
#include <vector>
#include <fstream>
#include <map>
#include <armadillo>

#include "SegmentedRegion.h"
#include "ColourSegment.h"
//#include "Vision/VisionTypes/colourreplacementrule.h"
//#include "Vision/VisionTypes/colourtransitionrule.h"

namespace modules {
    namespace vision {

		// Forward declarations to allow for compilation.
    	class ColourTransitionRule;
    	class ColourReplacementRule;

		class SegmentFilter {
		public:
			static const bool PREFILTER_ON = true;
			
			enum COLOUR_CLASS {
				BALL_COLOUR,
				GOAL_COLOUR,
				// GOAL_Y_COLOUR,
				// GOAL_B_COLOUR,
				LINE_COLOUR,
				TEAM_CYAN_COLOUR,
				TEAM_MAGENTA_COLOUR,
				UNKNOWN_COLOUR
			};

			SegmentFilter();
			
			/**
			  @brief runs the segment filter over the horizontal and vertical segments std::lists.
			  This matches pairs of segments to preloaded transition rules and stores matching results
			  as transitions back on the blackboard. This method also calls some smoothing prefilters on the std::lists
			  which are also set by preloaded rules.
			  */
			void run(const SegmentedRegion& horizontalSegments, const SegmentedRegion& verticalSegments) const;
				
		private:
			/**
			  @brief runs the segment prefilter rules over a segment std::list.
			  @param scans the std::lists of segments.
			  @param result a smoothed result.
			  */
			void preFilter(const SegmentedRegion& scans, SegmentedRegion& result) const;
			
			/**
			  @brief runs the transition rules over a segment std::list.
			  @param scans the std::lists of segments - smoothed or unsmoothed.
			  @param result std::vectors of transition rule matches and the field object ids they map to.
			  */
			void filter(const SegmentedRegion& scans, std::map<COLOUR_CLASS, std::vector<ColourSegment>>& result) const;
		
			/**
			  @brief Applies a single rule to a segmented region.
			  @param scans the std::lists of segments - smoothed or unsmoothed.
			  @param rule The transition rule to apply.
			  @param matches the resulting std::list of transitions.
			  */
			void checkRuleAgainstRegion(const SegmentedRegion& scans, const ColourTransitionRule& rule, std::vector<ColourSegment>& matches) const;
			
			/**
			  @brief Applies a replacement rule to a triplet of segments.
			  @param before the first segment.
			  @param middle the second segment.
			  @param after the last segment.
			  @param replacement a reference to a std::vector of segments that should replace the middle segment.
			  @param dir the scan direction (vertical or horizontal).
			  */
			void applyReplacements(const ColourSegment& before, const ColourSegment& middle, const ColourSegment& after, std::vector<ColourSegment>& replacement, SegmentedRegion::ScanDirection dir) const;
				
			/**
			  @brief Joins any adjacent segments that are the same colour.
			  @param line the std::list of segments.
			  */
			void joinMatchingSegments(std::vector<ColourSegment>& line) const;

			/**
			  @brief Loads the transition rules from a pair of files.
			  @param filename the filename to load from, note that "_h.txt" and "_v.txt" will be appended to
				     this to find the actual files.
			  */
			void loadTransitionRules(const std::string& filename);
			
			/**
			  @brief Loads the replacement rules from a pair of files.
			  @param filename the filename to load from, note that "_h.txt" and "_v.txt" will be appended to
				     this to find the actual files.
			  */
			void loadReplacementRules(const std::string& filename);
		
		private:
			std::vector<ColourReplacementRule> m_horizontalReplacementRules;	//! @variable The std::list of horizontal replacement rules
			std::vector<ColourReplacementRule> m_verticalReplacementRules;		//! @variable The std::list of vertical replacement rules
			std::vector<ColourTransitionRule> m_horizontalRules;				//! @variable The std::list of horizontal transition rules
			std::vector<ColourTransitionRule> m_verticalRules;					//! @variable The std::list of vertical transition rules
    	};
    	
// 		TODO: Replace these with the proper classes.
    	class ColourTransitionRule {
    	public:
			static ColourSegment nomatch;   //! @variable A static segment used to represent one that cannot be matched to any rule.

			ColourTransitionRule() {}
			bool match(const ColourSegment& before, const ColourSegment& middle, const ColourSegment& after) const {return false;}
			SegmentFilter::COLOUR_CLASS getColourClass() const {return SegmentFilter::UNKNOWN_COLOUR;}
    	};
    	
    	class ColourReplacementRule {
    	public:
		    static ColourSegment nomatch;   //! @variable a static segment used to represent one that cannot be matched to any rule.
		    
			enum ReplacementMethod {
				BEFORE,
				AFTER,
				SPLIT,
				INVALID
			};
    
    	    ColourReplacementRule() {}
		    bool match(const ColourSegment& before, const ColourSegment& middle, const ColourSegment& after) const {return false;}
		    bool oneWayMatch(const ColourSegment& before, const ColourSegment& middle, const ColourSegment& after) const {return false;}
			ReplacementMethod getMethod() const {return INVALID;}
    
			//! output stream operator.
			friend std::ostream& operator<< (std::ostream& output, const ColourReplacementRule& c);
			//! output stream operator for a vector of rules.
			friend std::ostream& operator<< (std::ostream& output, const std::vector<ColourReplacementRule>& v);
			//! input stream operator.
			friend std::istream& operator>> (std::istream& input, ColourReplacementRule& c);
			//! input stream operator for a vector of rules.
			friend std::istream& operator>> (std::istream& input, std::vector<ColourReplacementRule>& v);
    	};
    	
    }  // vision
}  // modules

#endif  // MODULES_VISION_SEGMENTFILTER_H

